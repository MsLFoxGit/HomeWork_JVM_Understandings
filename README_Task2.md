# HomeWork_JVM_Experience
## ***Использование Metaspace***
![Alt-текст](Classes.jpg "Classes Metaspace CPU")
## ***Рисунок 1.***

1. К 20:00:58 в Мета были загружены необходимые JDK классы ,а также rg.reflections.Reflections; java.time.LocalTime;  java.util.ArrayList; java.util.List;
java.util.Set; и JvmExperience, с соответствующими static методами и полями.  Система находилась в состоянии ожидания. Об этом говорит график. И процессор и память и количество 
классов находятся в стабильном состоянии. 
2. Далее ожидание 30 сек.
3. В 20:01:22 ожидание заканчивается, запускается метод loadToMetaspaceAllFrom("io.vertx"); который грузит библиотеку io.vertx. Классы static методы, поля в MEtaspace. 
Это хорошо видно на графике. Старт загрузки первой библиотеки отмечен синим вертикальным пунктиром. Процесс загрузки Библиотеки io.vertx отмечен голубым цветом.
4. Далее красная точка на грвафике указывает момент времени, в котором все из библиотеки io.vertx загружено и система снова встает на ожидание на 3сек (Thread.sleep(3_000)). 
коричневая линия на графике.
5. Ожидание заканчивается, запускается метод loadToMetaspaceAllFrom("io.netty"); который грузит библиотеку io.netty. Классы static методы, поля в MEtaspace. 
Это хорошо видно на графике. Процесс загрузки Библиотеки io.netty отмечен розовым цветом .
6. Далее желтая точка на грвафике указывает момент времени, в котором все из библиотеки io.netty загружено и система снова встает на ожидание на 3сек (Thread.sleep(3_000)). 
коричневая линия на графике.
7. Ожидание заканчивается, запускается метод loadToMetaspaceAllFrom("org.springframework"); который грузит библиотеку org.springframework. Классы static методы, 
поля в MEtaspace. Это хорошо видно на графике. Процесс загрузки Библиотеки org.springframework отмечен синим цветом.
8. Далее розовая точка на грвафике указывает момент времени, в котором все из библиотеки org.springframework загружено и система снова встает на ожидание на 3сек (Thread.sleep(3_000)). 
коричневая линия на графике.
9. Ожидание заканчивается, переходим к рассмотрению графика heap.

### Вывод по приведенным графикам (не сильно вдаваясь в точные значения): 
1. Сравнивая по числу Классов, io.vertx и org.springframework приерно равны, а io.netty, более чем в 2 раза, больше каждого из них.
2. Сравнивая по объему памяти, io.vertx и org.springframework приерно равны, а io.netty, менее чем в 2 раза, меньше каждого из них.
3. Исходя из п.1. и п.2. Можно сказать, что при меньшем числе классов, библиотеки io.vertx и org.springframework более наполнены полями и методами, чем 
классы библиотеки io.netty
4. Также, рассмтривая работу CPU и GC на графике CPU (коричневая и голубая линии соответственно), можно сказать, что в процессе загрузки классов "сборщик" не подключался, 
а дальнейщаяя его работа никак не отразилась на размере Metaspace. Работу с heap рассмотрю ниже.
5. Также, рассмтривая работу CPU и GC на графике CPU (коричневая и голубая линии соответственно), можно сказать, что в процессе загрузки классов линейно росла нагрузка 
на процессор. (Первые три пика). 
6. После загрузки третьей библиотеки "org.springframework", Metaspace не увеличивалась в размерах. Это говорит о том, что в процессе дальнейшего выполнения программы, 
дополнительные библиотке не подгружались.

## Использование heap ( в дальнейшем по тексту "куча" )
![Alt-текст](heap.jpg "Heap CPU Classes ")
### ***Для меня осталось не понятным, откуда возникла "яма" в куче. ( на розовой линии графика кучи, помечено вопросом ) Судя по активити на графике CPU, сборщик в это время "отдыхал" см. рис.2.***

1. C 20:01:22 до 20:01:32 загружались библиотеки, в соответствии с этим росла и куча, туда добавлялись ( по моему мнению) final объекты для работы библиотек также возможно enum. Временные отрезки роста полностью совпадают с процессом загрзуки библиотек, и периодами остановки.
2. В 20:01:32 ( точка 0) начал создаваться List<SimpleObject> simpleObjects = createSimpleObjects(5_000_000). В резльтете куче (плюсом к уже имеющимся) появилось 5млн объектов SimpleObject. А размер выделенной памяти на List, как минимум на 5 млн (List создается с определнным запасом).  В точке 1 создание simpleObjects закончилось. система встает на ожидание 3сек до точки 2.
3. Далее процедура повторяется еще два раза. От точки 2 до 3 ( еще плюс 5 млн объектов SimpleObject в List). Итого 10 млн в листе, А размер выделенной памяти на List как минимум на 10 млн  (List создается с определнным запасом).  В точке 3 создание добавление в List simpleObjects закончилось. Cистема встает на ожидание 3сек до точки 4. 
4. Аналогично п.3. от точки 4 до точки 5. Итого 15млн объектов в Листе,  А размер выделенной памяти на List как минимум на 15млн.
5. ОТ точки 5 до точки 6 хорошо видна работа "сборщика". Мне кажется, в этот момент "подрезается" размер Листа ( зарезервированные пустые ячейки памяти) т.к. обращения к нему больше нет.
6. Далее система стабильна, без имзменений до завершения работы.

